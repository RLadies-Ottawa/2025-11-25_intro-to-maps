---
title: "Design your own custom map"
author: "Reiko Okamoto"
format: html
editor: visual
---

Inspiration: <https://mrkyourmoment.com/en-ca/collections/city-prints/products/custom-city-map-1>

## Step 1: Load necessary packages

```{r}
library(tidyverse)
library(osmdata)
library(sf)
library(sysfonts)
library(showtext)
library(grid)
```

## Step 2: Define bounding box

```{r}
bbox <- c(
  xmin = -75.731,  # min longitude (western-most extent)
  ymin = 45.399,   # min latitude (southern-most extent)
  xmax = -75.667,  # max longitude (eastern-most extent)
  ymax = 45.444    # max latitude (northern-most extent)
)
```

## Step 3: Build Overpass query

```{r}
query <- opq(bbox = bbox)
```

## Step 4: Extract OSM data

```{r}
# rivers
water_a <- query |> 
  add_osm_feature(
    key = "natural", value = "water"
  ) |> 
  osmdata_sf()
```

```{r}
# other bodies of water
water_b <- query |> 
  add_osm_feature(
    key = "water", 
    value = c("lake", "canal", "pond", "basin", "lock")
  ) |> 
  osmdata_sf()
```

```{r}
# "major" roads
roads_a <- query |> 
  add_osm_feature(
    key = "highway",
    value = c(
      "motorway", "trunk", "primary",
      "motorway_link", "trunk_link", "primary_link"
    )
  ) |> 
  osmdata_sf()
```

```{r}
# "minor" roads
roads_b <- query |> 
  add_osm_feature(
    key = "highway",
    value = c(
      "secondary", "tertiary", "unclassified", "residential",
      "secondary_link", "tertiary_link"
    )
  ) |> 
  osmdata_sf()
```

```{r}
# natural vegetation
natural <- query |> 
  add_osm_feature(
    key = "natural",
    value = c("wood", "grassland", "scrub")
  ) |> 
  osmdata_sf()
```

```{r}
# recreational greenery
rec <- query |> 
  add_osm_features(
    list(
      "landuse" = c("grass", "forest", "recreation_ground"),
      "leisure" = c("playground", "park", "garden", "dog_park")
    )
  ) |> 
  osmdata_sf()
```

## Step 5: Crop sf objectsP

```{r}
bbox_sf <- st_as_sfc(st_bbox(bbox, crs = 4326))

water_a_cropped <- st_crop(water_a$osm_multipolygons, bbox_sf)
water_b_cropped <- st_crop(water_b$osm_polygons, bbox_sf)
roads_a_cropped <- st_crop(roads_a$osm_lines, bbox_sf)
roads_b_cropped <- st_crop(roads_b$osm_lines, bbox_sf)
natural_cropped <- st_crop(natural$osm_polygons, bbox_sf)
rec_cropped <- st_crop(rec$osm_polygons, bbox_sf)
```

**Posit Cloud users:** For some reason, cropping in Posit Cloud gives error: `Error in geos_op2_geom("intersection", x, y, ...) : st_crs(x) == st_crs(y) is not TRUE`. I'm not sure if this is the most graceful solution, but replace the previous code chunk with this one to bypass the error (we have to explicitly set the CRS of the OSM data).

```{r}
# bbox_sf <- st_as_sfc(st_bbox(bbox, crs = 4326))
# 
# water_a_cropped <- water_a$osm_multipolygons |> st_set_crs(4326) |> st_crop(bbox_sf)
# water_b_cropped <- water_b$osm_polygons |> st_set_crs(4326) |> st_crop(bbox_sf)
# roads_a_cropped <- roads_a$osm_lines |> st_set_crs(4326) |> st_crop(bbox_sf)
# roads_b_cropped <- roads_b$osm_lines |> st_set_crs(4326) |> st_crop(bbox_sf)
# natural_cropped <- natural$osm_polygons |> st_set_crs(4326) |> st_crop(bbox_sf)
# rec_cropped <- rec$osm_polygons |> st_set_crs(4326) |> st_crop(bbox_sf)
```

## Step 6: Visualize sf objects

```{r}
# define colour palette
water_colour <- "#d3e1e4"
roads_a_colour <- "#000000"
roads_b_colour <- "#171717"
natural_colour <- "#879682"
rec_colour <- "#c1cbba"
bkgd_colour <- "#f0f0f0"
```

```{r}
plt <- ggplot() +
  # rivers
  geom_sf(
    data = water_a_cropped, fill = water_colour, colour = NA
  ) +
  # other bodies of water
  geom_sf(
    data = water_b_cropped, fill = water_colour, colour = NA
  ) +
  # natural vegetation
  geom_sf(
    data = natural_cropped, fill = natural_colour, colour = NA
  ) +
  # recreational spaces
  geom_sf(
    data = rec_cropped, fill = rec_colour, colour = NA
  ) +
  # major roads
  geom_sf(
    data = roads_a_cropped, colour = roads_a_colour, size = 0.8, alpha = 0.9
  ) +
  # minor roads
  geom_sf(
    data = roads_b_cropped, colour = roads_b_colour, size = 0.5, alpha = 0.7
  ) +
  # remove margins
  coord_sf(expand = FALSE) +
  theme_void() +
  theme(
    panel.background = element_rect(fill = bkgd_colour)
  )
```

## Step 7: Add text and export

```{r}
# define colour palette
page_colour <- "#ffffff"
text_colour <- "#000000"
city <- "OTTAWA"
country <- "CANADA"
coordinates <- "45.422°N | 75.699°W"
```

```{r}
# use Grid Viewports to strategically position map and text
sysfonts::font_add_google("Montserrat", "Montserrat", regular.wt = 200)
png("ottawa-map.png", width = 8, height = 10, units = "in", res = 300)
showtext::showtext_begin()

vp1 <- viewport(x = 0.5, y = 0.5, width = 1, height = 1)
pushViewport(vp1)
grid.rect(gp = gpar(fill = page_colour))
upViewport()

vp2 <- viewport(x = 0.5, y = 0.575, width = 0.9, height = 0.75)
pushViewport(vp2)
print(plt, newpage = FALSE)
upViewport()

vp3 <- viewport(x = 0.75, y = 0.15, width = 0.4, height = 0.06, just = "left")
pushViewport(vp3)
grid.text(
  city, just = "right",
  gp = gpar(fontfamily = "Montserrat", fontsize = 36, col = text_colour)
)
upViewport()

vp4 <- viewport(x = 0.75, y = 0.1, width = 0.4, height = 0.03, just = "left")
pushViewport(vp4)
grid.text(
  country, just = "right",
  gp = gpar(fontfamily = "Montserrat", fontsize = 18, col = text_colour)
)
upViewport()

vp5 <- viewport(x = 0.75, y = 0.065, width = 0.4, height = 0.03, just = "left")
pushViewport(vp5)
grid.text(
  coordinates, just = "right",
  gp = gpar(fontfamily = "Montserrat", fontsize = 18, col = text_colour)
)
upViewport()

showtext::showtext_end()
dev.off()
```

## How to find which features you can plot

```{r}
# keys_to_check <- c("natural", "landuse", "leisure", "water")
# 
# # return all key-value pairs for selected keys within bounding box
# # warning: large bounding boxes can be computationally heavy!
# get_available_tags <- function(key, bbox) {
#   q <- opq(bbox) |> 
#     add_osm_feature(key = key)
#   osm_data <- osmdata_sf(q)
#   
#   # Extract unique values from all geometry types
#   values <- c()
#   if (!is.null(osm_data$osm_points)) 
#     values <- c(values, unique(osm_data$osm_points[[key]]))
#   if (!is.null(osm_data$osm_polygons)) 
#     values <- c(values, unique(osm_data$osm_polygons[[key]]))
#   if (!is.null(osm_data$osm_multipolygons)) 
#     values <- c(values, unique(osm_data$osm_multipolygons[[key]]))
#   
#   return(unique(values[!is.na(values)]))
# }
# 
# for (key in keys_to_check) {
#   values <- get_available_tags(key, bbox)
#   cat(sprintf("%s: %s\n", key, paste(values, collapse=", ")))
# }
```

## References

-   <https://thetidytrekker.com/post/making-circular-maps/making-circular-maps.html>

-   <https://blog.devgenius.io/design-a-map-art-with-r-and-openstreetmap-eac6fc7a912b>
